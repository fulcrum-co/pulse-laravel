<?php

namespace App\Services;

use App\Models\MiniCourse;
use App\Models\CourseApprovalWorkflow;
use App\Models\Organization;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;

class CourseApprovalService
{
    /**
     * Submit a course for approval.
     */
    public function submitForApproval(MiniCourse $course, int $userId): CourseApprovalWorkflow
    {
        $settings = $this->getOrgSettings($course->org_id);
        $mode = $settings['approval_mode'] ?? CourseApprovalWorkflow::MODE_CREATE_APPROVE;

        // Check if workflow already exists
        $workflow = $course->approvalWorkflow;

        if ($workflow) {
            // Resubmit existing workflow
            $workflow->resubmit();
        } else {
            // Create new workflow
            $workflow = CourseApprovalWorkflow::create([
                'mini_course_id' => $course->id,
                'status' => CourseApprovalWorkflow::STATUS_PENDING,
                'workflow_mode' => $mode,
                'submitted_by' => $userId,
                'submitted_at' => now(),
            ]);
        }

        // Update course status
        $course->update([
            'approval_status' => MiniCourse::APPROVAL_PENDING,
        ]);

        // Notify reviewers
        $this->notifyReviewers($course, $settings);

        Log::info('Course submitted for approval', [
            'course_id' => $course->id,
            'workflow_id' => $workflow->id,
            'submitted_by' => $userId,
        ]);

        return $workflow;
    }

    /**
     * Approve a course.
     */
    public function approve(CourseApprovalWorkflow $workflow, int $reviewerId, ?string $notes = null): void
    {
        $workflow->approve($reviewerId, $notes);

        $course = $workflow->course;

        // Publish the course if it's an auto-generated course
        if ($course->isAutoGenerated()) {
            $course->update([
                'status' => MiniCourse::STATUS_ACTIVE,
                'published_at' => now(),
            ]);
        }

        // Notify the submitter
        $this->notifyApprovalResult($workflow, 'approved');

        Log::info('Course approved', [
            'course_id' => $course->id,
            'workflow_id' => $workflow->id,
            'reviewer_id' => $reviewerId,
        ]);
    }

    /**
     * Reject a course.
     */
    public function reject(CourseApprovalWorkflow $workflow, int $reviewerId, string $reason): void
    {
        $workflow->reject($reviewerId, $reason);

        // Notify the submitter
        $this->notifyApprovalResult($workflow, 'rejected');

        Log::info('Course rejected', [
            'course_id' => $workflow->mini_course_id,
            'workflow_id' => $workflow->id,
            'reviewer_id' => $reviewerId,
            'reason' => $reason,
        ]);
    }

    /**
     * Request revision on a course.
     */
    public function requestRevision(CourseApprovalWorkflow $workflow, int $reviewerId, string $feedback): void
    {
        $workflow->requestRevision($reviewerId, $feedback);

        // Notify the submitter
        $this->notifyApprovalResult($workflow, 'revision_requested');

        Log::info('Course revision requested', [
            'course_id' => $workflow->mini_course_id,
            'workflow_id' => $workflow->id,
            'reviewer_id' => $reviewerId,
        ]);
    }

    /**
     * Check if a course should auto-activate based on org settings.
     */
    public function shouldAutoActivate(MiniCourse $course): bool
    {
        $settings = $this->getOrgSettings($course->org_id);
        $mode = $settings['approval_mode'] ?? CourseApprovalWorkflow::MODE_CREATE_APPROVE;

        return $mode === CourseApprovalWorkflow::MODE_AUTO_ACTIVATE;
    }

    /**
     * Get pending approvals for an organization.
     */
    public function getPendingApprovals(int $orgId): Collection
    {
        return CourseApprovalWorkflow::pending()
            ->whereHas('course', function ($q) use ($orgId) {
                $q->where('org_id', $orgId);
            })
            ->with(['course', 'submitter'])
            ->orderBy('submitted_at')
            ->get();
    }

    /**
     * Get all pending approvals count.
     */
    public function getPendingApprovalsCount(int $orgId): int
    {
        return CourseApprovalWorkflow::pending()
            ->whereHas('course', function ($q) use ($orgId) {
                $q->where('org_id', $orgId);
            })
            ->count();
    }

    /**
     * Get approvals by status for an organization.
     */
    public function getApprovalsByStatus(int $orgId, string $status): Collection
    {
        return CourseApprovalWorkflow::where('status', $status)
            ->whereHas('course', function ($q) use ($orgId) {
                $q->where('org_id', $orgId);
            })
            ->with(['course', 'submitter', 'reviewer'])
            ->orderByDesc('reviewed_at')
            ->get();
    }

    /**
     * Get recent approval activity for an organization.
     */
    public function getRecentActivity(int $orgId, int $limit = 10): Collection
    {
        return CourseApprovalWorkflow::whereHas('course', function ($q) use ($orgId) {
            $q->where('org_id', $orgId);
        })
            ->with(['course', 'submitter', 'reviewer'])
            ->orderByDesc('updated_at')
            ->limit($limit)
            ->get();
    }

    /**
     * Bulk approve courses.
     */
    public function bulkApprove(array $workflowIds, int $reviewerId, ?string $notes = null): array
    {
        $results = ['success' => 0, 'failed' => 0];

        foreach ($workflowIds as $workflowId) {
            try {
                $workflow = CourseApprovalWorkflow::find($workflowId);
                if ($workflow && $workflow->isPending()) {
                    $this->approve($workflow, $reviewerId, $notes);
                    $results['success']++;
                } else {
                    $results['failed']++;
                }
            } catch (\Exception $e) {
                $results['failed']++;
                Log::error('Bulk approval failed for workflow', [
                    'workflow_id' => $workflowId,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        return $results;
    }

    /**
     * Bulk reject courses.
     */
    public function bulkReject(array $workflowIds, int $reviewerId, string $reason): array
    {
        $results = ['success' => 0, 'failed' => 0];

        foreach ($workflowIds as $workflowId) {
            try {
                $workflow = CourseApprovalWorkflow::find($workflowId);
                if ($workflow && $workflow->isPending()) {
                    $this->reject($workflow, $reviewerId, $reason);
                    $results['success']++;
                } else {
                    $results['failed']++;
                }
            } catch (\Exception $e) {
                $results['failed']++;
                Log::error('Bulk rejection failed for workflow', [
                    'workflow_id' => $workflowId,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        return $results;
    }

    /**
     * Get organization settings.
     */
    protected function getOrgSettings(int $orgId): array
    {
        $org = Organization::find($orgId);

        if (!$org) {
            return $this->getDefaultSettings();
        }

        $settings = $org->settings ?? [];

        return $settings['ai_course_settings'] ?? $this->getDefaultSettings();
    }

    /**
     * Get default settings.
     */
    protected function getDefaultSettings(): array
    {
        return [
            'approval_mode' => CourseApprovalWorkflow::MODE_CREATE_APPROVE,
            'auto_generate_enabled' => false,
            'generation_triggers' => ['manual'],
            'notification_recipients' => ['admin'],
            'max_auto_courses_per_day' => 10,
            'require_review_for_ai_generated' => true,
        ];
    }

    /**
     * Notify reviewers about pending course.
     */
    protected function notifyReviewers(MiniCourse $course, array $settings): void
    {
        $recipients = $settings['notification_recipients'] ?? ['admin'];

        // In production, dispatch notification
        Log::info('Notifying reviewers about pending course', [
            'course_id' => $course->id,
            'recipients' => $recipients,
        ]);

        // TODO: Implement actual notification dispatch
        // Notification::send($users, new CourseAwaitingApprovalNotification($course));
    }

    /**
     * Notify about approval result.
     */
    protected function notifyApprovalResult(CourseApprovalWorkflow $workflow, string $result): void
    {
        Log::info('Notifying about approval result', [
            'workflow_id' => $workflow->id,
            'result' => $result,
            'submitted_by' => $workflow->submitted_by,
        ]);

        // TODO: Implement actual notification dispatch
        // if ($workflow->submitter) {
        //     $workflow->submitter->notify(new CourseApprovalResultNotification($workflow, $result));
        // }
    }
}
